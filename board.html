<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>講習会掲示板</title>
  <style>
    :root {
      --border: #e5e7eb;
      --muted: #6b7280;
      --bg: #f7f8fb;
    }
    /* Ensure widths include padding and borders so edges line up */
    *, *::before, *::after { box-sizing: border-box; }
    html, body { height: 100%; }
    body { margin: 0; background: var(--bg); color: #111; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 1080px; margin: 0 auto; padding: 24px; }
    h1 { font-size: 1.6rem; margin: 0 0 .25rem; }
    .sub { color: var(--muted); font-size: .95rem; margin: 0 0 16px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 24px; align-items: start; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }
    .card { background: #fff; border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 1px 2px rgba(16,24,40,.04); }
    .card h2 { font-size: 1.05rem; margin: 0 0 8px; }
    .card .body { padding: 16px; }
    .list-body { padding: 16px 16px 0; }
    .row { display: flex; align-items: center; gap: .5rem; flex-wrap: wrap; }
    .row > * { margin: .25rem 0; }
    .pill { background: #f1f5f9; border: 1px solid var(--border); padding: .25rem .6rem; border-radius: 999px; font-size: .78rem; color: #111; }
    textarea { width: 100%; min-height: 140px; padding: .8rem; border: 1px solid #cbd5e1; border-radius: 10px; font: inherit; resize: vertical; background: #fff; }
    textarea:focus { outline: 2px solid #2563eb22; border-color: #93c5fd; }
    .controls { display: flex; align-items: center; justify-content: space-between; margin: 8px 0 14px; }
    .hint { color: #64748b; font-size: .85rem; }
    .count { color: #94a3b8; font-size: .85rem; }
    button { background: #111; color: #fff; border: 0; border-radius: 10px; padding: .6rem 1rem; cursor: pointer; font-weight: 600; }
    button[disabled] { opacity: .6; cursor: not-allowed; }
    .status { color: #475569; font-size: .85rem; margin-top: .25rem; min-height: 1.2em; }
    .ok { color: #0f9d58; }
    .err { color: #c0392b; }
    .list-wrap { padding: 0; margin: 0 -16px -16px; }
    /* Simplified list: no inner card, full-bleed lines */
    .list { border-top: 1px solid var(--border); border-bottom: 0; border-left: 0; border-right: 0; border-radius: 0; padding: 0; max-height: 70vh; overflow: auto; background: transparent; }
    .item { margin: 0; padding: 1rem 16px; border-top: 1px solid var(--border); background: transparent; }
    .item:first-child { border-top: 0; }
    .item-head { display:flex; align-items:center; justify-content:space-between; margin-bottom: .35rem; }
    .item-id { color: #94a3b8; font-size: .8rem; font-weight: 400; font-variant-numeric: tabular-nums; }
    .meta { color: #94a3b8; font-size: .8rem; }
    .item-text { font-size: 1.06rem; line-height: 1.6; }
    .header-line { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; }
    .item-actions { display:flex; align-items:center; gap:.75rem; margin-top:.5rem; }
    .like-btn { display:inline-flex; align-items:center; gap:.35rem; padding:.2rem .25rem; border:0; background:transparent; color:#64748b; font-size:.9rem; cursor:pointer; }
    .like-btn:hover { color:#111; }
    .like-btn:disabled { opacity:.6; cursor:not-allowed; }
    .like-btn .heart { width:18px; height:18px; stroke: currentColor; fill: transparent; stroke-width: 2; }
    .like-btn.liked { color:#ef4444; }
    .like-btn.liked .heart { fill: currentColor; }
    .like-count { font-variant-numeric: tabular-nums; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>掲示板</h1>
    <div class="sub">Gemini CLI講習会用の掲示板です。</div>
    <div class="row">
      <a href="./" class="pill">← ホームに戻る</a>
    </div>
    <div class="grid">
      <div class="card">
        <div class="body">
          <div class="header-line">
            <h2>投稿</h2>
            <div class="row">
              <div class="pill">更新: <span id="sync"></span></div>
            </div>
          </div>
          <textarea id="text" placeholder="例: Codespaces で URL が出ません。 どうすれば良いですか？"></textarea>
          <div class="controls">
            <div class="count" id="count">0 / 300</div>
          </div>
          <button id="send">投稿する</button>
          <div id="postStatus" class="status"></div>
        </div>
      </div>

      <div class="card">
        <div class="body list-body">
          <div class="header-line">
            <h2>投稿一覧</h2>
          </div>
          <div class="row" style="justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <div class="pill">総件数: <span id="totalCount">-</span></div>
            <div class="row" style="gap:.5rem;">
              <button id="prevPage" class="pill" style="cursor:pointer;">← 前へ</button>
              <div class="pill">ページ <span id="pageNow">1</span> / <span id="pageMax">1</span></div>
              <button id="nextPage" class="pill" style="cursor:pointer;">次へ →</button>
            </div>
          </div>
          <div class="list-wrap">
            <div class="list" id="list"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // Auto-select API base:
    // - If served from localhost:5500, use local Worker (wrangler dev)
    // - Otherwise, use the deployed Worker URL
    // - `?api=` remains as an optional manual override
    const _params = new URLSearchParams(location.search);
    const _override = _params.get('api');
    // Robust localhost detection (IPv4/IPv6) for :5500
    const _isLocalHost = (
      location.protocol === 'http:' &&
      location.port === '5500' &&
      (
        location.hostname === 'localhost' ||
        location.hostname === '127.0.0.1' ||
        location.hostname === '::1' ||
        location.hostname === '::'
      )
    );
    const _defaultBase = _isLocalHost
      ? 'http://127.0.0.1:8787'
      : 'https://anon-board.jonah-egashira.workers.dev';
    const API_BASE = _override || _defaultBase;

    const MAX = 300;
    const PAGE_SIZE = 50; // 1ページあたり件数（表示）
    const textEl = document.getElementById('text');
    const sendBtn = document.getElementById('send');
    const countEl = document.getElementById('count');
    const statusEl = document.getElementById('postStatus');
    const listEl = document.getElementById('list');
    const totalCountEl = document.getElementById('totalCount');
    const pageNowEl = document.getElementById('pageNow');
    const pageMaxEl = document.getElementById('pageMax');
    const prevPageBtn = document.getElementById('prevPage');
    const nextPageBtn = document.getElementById('nextPage');
    const syncEl = document.getElementById('sync');
    // ページネーション（クライアント側）用の状態
    let currentPage = 1; // 1-indexed
    // Optimistic UI support
    let serverItems = []; // 全件（新しい順）
    let pending = []; // { id, ts, text, _until }
    const liking = new Set(); // in-flight like ops by id

    function escapeHtml(s) {
      return s.replace(/[&<>"']/g, c => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c]));
    }

    textEl.addEventListener('input', () => {
      const val = textEl.value;
      if (val.length > MAX) {
        textEl.value = val.slice(0, MAX);
      }
      countEl.textContent = `${textEl.value.length} / ${MAX}`;
    });

    async function post() {
      const text = textEl.value.trim();
      if (!text) return;
      sendBtn.disabled = true; statusEl.textContent = '送信中...'; statusEl.className = 'status';
      try {
        const res = await fetch(`${API_BASE}/api/messages`, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ text })
        });
        const data = await res.json();
        if (!res.ok) throw new Error(data?.message || '送信に失敗しました');
        textEl.value = ''; countEl.textContent = `0 / ${MAX}`;
        statusEl.textContent = '送信しました'; statusEl.className = 'status ok';
        // 楽観的表示: 即時に先頭へ反映（最大90秒保持）
        pending.unshift({ ...data, _until: Date.now() + 90_000 });
        renderAll(serverItems);
        // サーバー側の反映を取得
        await loadAll();
      } catch (e) {
        statusEl.textContent = e.message;
        statusEl.className = 'status err';
      } finally {
        sendBtn.disabled = false;
      }
    }

    sendBtn.addEventListener('click', post);
    textEl.addEventListener('keydown', (e) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') post();
    });

    function renderAll(items) {
      serverItems = items || [];
      // Drop expired pending
      const now = Date.now();
      pending = pending.filter(p => (p._until || 0) > now);

      // Prefer server items; add pending only if not present
      const byId = new Map(serverItems.map(it => [it.id, it]));
      for (const p of pending) if (!byId.has(p.id)) byId.set(p.id, p);

      const combined = Array.from(byId.values()).sort((a,b) => b.ts - a.ts);
      totalCountEl.textContent = combined.length.toString();
      const maxPage = Math.max(1, Math.ceil(combined.length / PAGE_SIZE));
      if (currentPage > maxPage) currentPage = maxPage;
      pageNowEl.textContent = String(currentPage);
      pageMaxEl.textContent = String(maxPage);
      prevPageBtn.disabled = currentPage <= 1;
      nextPageBtn.disabled = currentPage >= maxPage;

      const start = (currentPage - 1) * PAGE_SIZE;
      const end = start + PAGE_SIZE;
      const pageItems = combined.slice(start, end);

      listEl.innerHTML = pageItems.map((it, i) => {
        const when = new Date(it.ts).toLocaleTimeString();
        const globalIndex = start + i; // index within combined (0 = newest)
        const no = combined.length - globalIndex; // global sequential number
        const liked = localStorage.getItem(`liked:${it.id}`) === '1';
        const likes = typeof it.likes === 'number' ? it.likes : 0;
        const shortId = (it.id || '').split('-').pop();
        return `
          <div class="item">
            <div class="item-head">
              <div class="item-id">No: ${no} <span class="meta" style="margin-left:.5rem;">ID: ${shortId}</span></div>
              <div class="meta">${when}</div>
            </div>
            <div class="item-text">${escapeHtml(it.text)}</div>
            <div class="item-actions">
              <button class="like-btn${liked ? ' liked' : ''}" data-id="${it.id}" aria-pressed="${liked}" title="Like">
                <svg class="heart" viewBox="0 0 24 24" aria-hidden="true">
                  <path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78L12 21.23l8.84-8.84a5.5 5.5 0 0 0 0-7.78z"></path>
                </svg>
                <span class="like-count" id="lc-${it.id}">${likes}</span>
              </button>
            </div>
          </div>
        `;
      }).join('');
    }

    // Like/unlike handlers (event delegation)
    listEl.addEventListener('click', async (e) => {
      const btn = e.target.closest('.like-btn');
      if (!btn) return;
      const id = btn.getAttribute('data-id');
      if (!id || liking.has(id)) return;
      liking.add(id);
      const liked = btn.classList.contains('liked');
      try {
        btn.disabled = true;
        if (liked) {
          await unlike(id);
          localStorage.removeItem(`liked:${id}`);
          btn.classList.remove('liked');
          btn.setAttribute('aria-pressed', 'false');
        } else {
          await like(id);
          localStorage.setItem(`liked:${id}`, '1');
          btn.classList.add('liked');
          btn.setAttribute('aria-pressed', 'true');
        }
      } catch (err) {
      } finally {
        btn.disabled = false;
        liking.delete(id);
      }
    });

    async function like(id) {
      const res = await fetch(`${API_BASE}/api/messages/${encodeURIComponent(id)}/like`, {
        method: 'POST',
        credentials: 'include'
      });
      const data = await res.json();
      if (!res.ok) throw new Error('like failed');
      const el = document.getElementById(`lc-${id}`);
      if (el) el.textContent = data.likes ?? el.textContent;
    }

    async function unlike(id) {
      const res = await fetch(`${API_BASE}/api/messages/${encodeURIComponent(id)}/like`, {
        method: 'DELETE',
        credentials: 'include'
      });
      const data = await res.json();
      if (!res.ok) throw new Error('unlike failed');
      const el = document.getElementById(`lc-${id}`);
      if (el) el.textContent = data.likes ?? el.textContent;
    }

    async function loadAll() {
      try {
        const merged = [];
        let cursor = undefined;
        let page = 0;
        do {
          const url = new URL(`${API_BASE}/api/messages`);
          url.searchParams.set('limit', '200');
          if (cursor) url.searchParams.set('cursor', cursor);
          const res = await fetch(url, { cache: 'no-store' });
          const data = await res.json();
          if (!res.ok) throw new Error('読込に失敗しました');
          const items = Array.isArray(data.items) ? data.items : [];
          merged.push(...items);
          cursor = data.cursor || null;
          page += 1;
          // Safety: avoid infinite loops
          if (page > 200) break;
        } while (cursor);

        // Sort newest first (safety)
        merged.sort((a,b) => b.ts - a.ts);

        // Change detection by IDs
        const key = JSON.stringify(merged.map(i => i.id));
        if (key !== loadAll._lastKey) {
          renderAll(merged);
          loadAll._lastKey = key;
        } else {
          // update header info even if same
          totalCountEl.textContent = String(merged.length);
          pageMaxEl.textContent = String(Math.max(1, Math.ceil(merged.length / PAGE_SIZE)));
        }

        syncEl.textContent = new Date().toLocaleTimeString();
      } catch (e) {
      }
    }
    loadAll._lastKey = '';

    // ページ切り替え
    prevPageBtn.addEventListener('click', () => { if (currentPage > 1) { currentPage -= 1; renderAll(serverItems); } });
    nextPageBtn.addEventListener('click', () => {
      const maxPage = Math.max(1, Math.ceil(serverItems.length / PAGE_SIZE));
      if (currentPage < maxPage) { currentPage += 1; renderAll(serverItems); }
    });

    // 初回ロードとポーリング（全件）
    loadAll();
    setInterval(loadAll, 10000);
  </script>
</body>
</html>
